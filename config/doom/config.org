#+TITLE: Doom Emacs Configuration
#+AUTHOR: Sebastian Funk
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent

This is my literate Doom Emacs configuration. Each section contains explanations
of what the code does and why certain choices were made.

After editing this file, run =doom sync= to regenerate config.el and packages.el.

* Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle packages.el
:END:

These package declarations are tangled to =packages.el=. Doom uses these to
install packages from MELPA, ELPA, or directly from git repos.

** ESS Extensions
#+begin_src emacs-lisp
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

(package! ess-smart-equals)        ; context-aware = key in ESS
(package! tree-sitter-ess-r)       ; tree-sitter support for R
#+end_src

** Org Extensions
#+begin_src emacs-lisp
(package! org-ref)                 ; citations and cross-references
(package! vulpea)                  ; org-roam workflow helpers
#+end_src

** Communication
#+begin_src emacs-lisp
(package! telega)                  ; Telegram client
(package! mastodon)                ; Mastodon client
#+end_src

** AI Tools
#+begin_src emacs-lisp
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
(package! aidermacs)               ; Aider AI pair programming
(package! claude-code-ide
  :recipe (:host github :repo "manzaltu/claude-code-ide.el"))
#+end_src

** Development
#+begin_src emacs-lisp
(package! quarto-mode)             ; Quarto documents
(package! eglot-jl)                ; Julia LSP via eglot
(package! code-review
  :recipe (:host github :repo "doomelpa/code-review"))
#+end_src

** Editing
#+begin_src emacs-lisp
(package! evil-embrace)            ; mode-specific surrounds
(package! atomic-chrome)           ; edit browser text in Emacs
#+end_src

* Private Configuration
Load private settings (emails, accounts) from a separate file.
This file lives in the private dotfiles repo and is symlinked to =~/.config/doom-private/=.
#+begin_src emacs-lisp
(load! "private.el" "~/.config/doom-private" t)
#+end_src

* Basic Configuration
** Fonts
- =Fira Code= - monospace font with ligatures for code
- =Source Sans 3= - clean sans-serif for prose/variable-pitch

Adjust =:size= if text is too small/large on your display.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "Source Sans 3" :size 13))
#+end_src

** Theme and UI
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
(setq display-line-numbers-type t)
#+end_src

** Show Modeline in All Popups
Doom's popup system hides the modeline by default. Always show it so we can
tell which window has focus.
#+begin_src emacs-lisp
(defadvice! +popup-always-show-modeline-a (&rest _)
  "Always show modeline in popups."
  :after #'+popup-set-modeline-on-enable-h
  (setq-local mode-line-format (default-value 'mode-line-format)))
#+end_src

** Highlight Active Modeline
Make the active window's modeline more prominent. Uses the theme's highlight color
so it works across different themes.
#+begin_src emacs-lisp
(custom-set-faces!
  '(mode-line :inherit highlight :box nil)
  '(mode-line-inactive :inherit shadow :box nil))
#+end_src

** macOS Modifier Keys
This makes Emacs feel more natural on macOS:
- *Command* (⌘) → Meta (M-) for Emacs commands
- *Option* (⌥) → Super (s-) available for custom bindings
- *Right Option* → passes through for special characters (umlauts, etc.)
#+begin_src emacs-lisp
(setq mac-option-modifier 'super)
(setq mac-right-option-modifier 'none)
(setq mac-command-modifier 'meta)
#+end_src

** GPG
Allow Emacs to prompt for GPG passphrase in minibuffer.
#+begin_src emacs-lisp
(setf epa-pinentry-mode 'loopback)
#+end_src

* Email
Email configuration is in a separate file (tangled from email.org).
#+begin_src emacs-lisp
(load! "email")
#+end_src

* ESS (Emacs Speaks Statistics)
ESS provides IDE-like features for R, Julia, and other statistical languages.

** Smart Equals and Basic Settings
=ess-smart-equals= makes === context-aware - it inserts =<-= in the right places.
#+begin_src emacs-lisp
(after! ess
  (use-package ess-smart-equals
    :init   (setq ess-smart-equals-extra-ops '(brace paren percent))
    :after  (:any ess-r-mode inferior-ess-r-mode ess-r-transcript-mode)
    :config (ess-smart-equals-activate))
  (setq comint-scroll-to-bottom-on-output 'others)
  (setq comint-scroll-show-maximum-output t)
  (setq ess-nuke-trailing-whitespace-p t)
  (setq ess-r-smart-operators t)
  (setq comint-scroll-to-bottom-on-input 'this)
#+end_src

** Pipe Operators
Custom functions for inserting the native R pipe operator =|>=.

| Key   | Action                    |
|-------+---------------------------|
| =C-`= | Insert pipe with newline  |
| =C-~= | Insert pipe without newline |
#+begin_src emacs-lisp
  (defun then_newline_R_operator ()
    "|> operator or 'then' pipe operator"
    (interactive)
    (just-one-space 1)
    (insert "|> ")
    (ess-roxy-newline-and-indent))
  (defun then_R_operator ()
    "|> operator or 'then' pipe operator"
    (interactive)
    (just-one-space 1)
    (insert "|> "))
  (setq tab-always-indent 'complete)
#+end_src

** Roxygen Templates
Default template for R documentation comments.
#+begin_src emacs-lisp
  (setq ess-roxy-template-alist
    (list (cons "description"  ".. content for \\description{} (no empty lines) ..")
          (cons "param"  "")
          (cons "return" "")
          (cons "examples" ""))))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(map! :after ess
 (:map inferior-ess-r-mode-map
  :n "0" #'comint-bol
  :i "C-`" #'then_newline_R_operator
  :i "C-~" #'then_R_operator)
 (:map ess-mode-map
  :i "C-`" #'then_newline_R_operator
  :i "C-~" #'then_R_operator)
 (:map comint-mode-map
  :i "M-k" #'comint-previous-matching-input-from-input
  :i "M-j" #'comint-next-matching-input-from-input))
#+end_src

** Inferior ESS Hook
#+begin_src emacs-lisp
(defun my-inferior-ess-init ()
  (setq-local ansi-color-for-comint-mode 'filter)
  (smartparens-mode 1))
(add-hook 'inferior-ess-mode-hook 'my-inferior-ess-init)
#+end_src

* Julia
** Why ESS-Julia instead of julia-repl?
Doom's default Julia setup uses =julia-repl=, but it has limitations:
- Each buffer gets its own REPL (annoying in Quarto with multiple code blocks)
- No easy way to switch between multiple Julia sessions

ESS-Julia gives us the same workflow as R:
- =C-c C-s= to switch between Julia sessions
- =C-u M-x julia= to start a named session
- All buffers share the same REPL by default

** ESS-Julia Mode
#+begin_src emacs-lisp
(after! julia-mode
  ;; Disable julia-repl-mode which Doom enables by default
  (remove-hook 'julia-mode-hook #'julia-repl-mode)
  ;; Use ess-julia-mode for .jl files
  (add-to-list 'auto-mode-alist '("\\.jl\\'" . ess-julia-mode)))

(after! ess
  ;; Julia executable (adjust path if needed)
  (setq inferior-julia-program "julia")

  ;; Window placement for Julia REPL - right side, 45% width
  (set-popup-rule! "^\\*julia.*\\*$"
    :side 'right :size 0.45 :select nil :quit nil :ttl nil))
#+end_src

** Quarto/Polymode Integration
This makes =M-n v v= (eval chunk) work in Julia code blocks within Quarto files,
just like it does for R. Without this, each code block would try to start a new REPL.

| Key       | Action                    |
|-----------+---------------------------|
| =M-n v v= | Eval current chunk        |
| =M-n v b= | Eval whole buffer         |
| =C-c C-c= | Eval region/paragraph     |
| =C-c C-s= | Switch Julia session      |
#+begin_src emacs-lisp
(after! polymode
  ;; Tell polymode to use ess-julia-mode for julia code blocks
  (add-to-list 'polymode-mode-name-override-alist '(julia . ess-julia-mode))

  ;; Define the eval function for Julia (like poly-R does for R)
  (defun poly-julia-eval-region (beg end msg)
    "Eval region in Julia using ESS."
    (ess-eval-region beg end nil msg))

  ;; Set up polymode eval for ess-julia-mode in polymode buffers
  (add-hook 'polymode-init-inner-hook
            (lambda ()
              (when (eq major-mode 'ess-julia-mode)
                (setq-local polymode-eval-region-function #'poly-julia-eval-region)))))
#+end_src

** REPL Display
Ensure Julia REPL window is displayed when evaluating code (it was staying hidden).
#+begin_src emacs-lisp
(after! ess
  (defun my/display-julia-repl (&rest _)
    "Display Julia REPL buffer if it exists."
    (when-let ((buf (seq-find (lambda (b)
                                (string-match-p "^\\*julia:" (buffer-name b)))
                              (buffer-list))))
      (unless (get-buffer-window buf)
        (display-buffer buf '((display-buffer-reuse-window
                               display-buffer-pop-up-window)
                              (reusable-frames . nil))))))
  ;; Show buffer after eval commands
  (advice-add 'ess-eval-region :after #'my/display-julia-repl)
  (advice-add 'ess-eval-region-or-function-or-paragraph :after #'my/display-julia-repl))

(setq lsp-julia-package-dir nil)
(setq lsp-julia-default-environment "~/.julia/environments/v1.11")
#+end_src

* Python
#+begin_src emacs-lisp
(setq python-interpreter "~/.venv/bin/python")
(setq python-shell-interpreter "~/.venv/bin/python")
#+end_src

* Polymode
Disable LSP integration with polymode to avoid issues with multi-mode buffers.
See https://github.com/polymode/poly-R/issues/34
#+begin_src emacs-lisp
(setq polymode-lsp-integration nil)
#+end_src

* Magit
** Default Clone Directory
#+begin_src emacs-lisp
(after! magit
  (setq magit-clone-default-directory "~/code/"))
#+end_src

** Automatic Workspace Creation
This is a custom workflow enhancement. When you run =magit-status= or =magit-clone=
on a repository:

1. The repo is added to projectile's known projects (so =SPC p p= finds it)
2. A workspace is created/switched to, named after the repo
3. Magit opens fullframe in that workspace

This means =SPC g g ~/code/new-project= instantly sets up a complete workspace.
#+begin_src emacs-lisp
(after! magit
  (defun my/magit-setup-workspace ()
    "Ensure project is registered with projectile and has a workspace."
    (when-let* ((root (or (magit-toplevel) default-directory))
                (name (file-name-nondirectory (directory-file-name root))))
      ;; Add to projectile's known projects
      (projectile-add-known-project root)
      ;; Create or switch to workspace (only if not already there)
      (unless (string= (+workspace-current-name) name)
        (if (member name (+workspace-list-names))
            (+workspace-switch name)
          ;; New workspace
          (+workspace-switch name t)
          ;; Clean up after everything settles
          (run-at-time 0.1 nil #'delete-other-windows)))))

  ;; Run when opening magit-status
  (add-hook 'magit-status-mode-hook #'my/magit-setup-workspace)
  ;; Run after cloning a repo
  (add-hook 'magit-post-clone-hook #'my/magit-setup-workspace))
#+end_src

* Workspaces and Projectile
Doom's workspaces (built on =persp-mode=) provide buffer isolation per project.
This is essential for keeping different projects separate.

** Key Bindings Reference
| Key           | Action                              |
|---------------+-------------------------------------|
| =SPC TAB TAB= | Switch workspace                    |
| =SPC TAB n=   | New workspace                       |
| =SPC TAB d=   | Delete workspace                    |
| =SPC TAB r=   | Rename workspace                    |
| =SPC b b=     | Switch buffer (workspace only)      |
| =SPC b B=     | Switch buffer (all buffers)         |
| =SPC b r=     | Remove buffer from workspace        |
| =SPC p p=     | Switch project (creates workspace)  |

** Basic Setup
#+begin_src emacs-lisp
(setq +workspaces-on-switch-project-behavior t)  ; auto-create workspace per project
(setq persp-auto-save-opt 1)                      ; save workspaces on exit
(setq projectile-project-search-path '("~/code/")) ; where to find projects
#+end_src

** Auto-rename Workspaces
By default, workspaces get names like "code/EpiNow2". This strips the path prefix
so they're just "EpiNow2". If a workspace with that name already exists, switch to it
instead of creating a duplicate.
#+begin_src emacs-lisp
(after! persp-mode
  (add-hook 'projectile-after-switch-project-hook
            (lambda ()
              (let* ((current (+workspace-current-name))
                     (basename (file-name-nondirectory (directory-file-name current))))
                (unless (string= current basename)
                  (if (member basename (+workspace-list-names))
                      ;; Workspace with basename exists - switch to it and delete the new one
                      (let ((new-ws current))
                        (+workspace-switch basename)
                        (+workspace-delete new-ws))
                    ;; No conflict - just rename
                    (+workspace/rename basename)))))))
#+end_src

** Buffer Management
Remove a buffer from the current workspace without killing it.
The buffer is still accessible via =SPC b B= (global buffer list).
#+begin_src emacs-lisp
(map! :leader
      :desc "Remove buffer from workspace" "b W" #'persp-remove-buffer)
#+end_src

* Org Mode
** Directories
#+begin_src emacs-lisp
(setq org-directory "~/org")

;; Dedicated org workspace (like mail)
(defun sf/switch-to-org-workspace ()
  "Switch to or create the org workspace."
  (+workspace-switch "org" t))

(defun sf/org-in-workspace (orig-fun &rest args)
  "Run org command in dedicated org workspace."
  (sf/switch-to-org-workspace)
  (apply orig-fun args))

(advice-add 'org-agenda :around #'sf/org-in-workspace)
(advice-add 'org-todo-list :around #'sf/org-in-workspace)
#+end_src

** Dynamic Agenda Files
Agenda includes only files with :active: filetag from ~/org-roam.
#+begin_src emacs-lisp
(defvar sf/notes-directory "~/org-roam"
  "Directory containing org-roam/vulpea notes.")

(defun sf/org-active-files ()
  "Return list of org files with 'active' filetag."
  (let ((files (directory-files sf/notes-directory nil "\\.org$"))
        result)
    (dolist (file files)
      (let ((filepath (expand-file-name file sf/notes-directory)))
        (with-temp-buffer
          (insert-file-contents filepath nil 0 500)
          (when (re-search-forward "^#\\+filetags:.*:active:" nil t)
            (push filepath result)))))
    (or result (list sf/notes-directory))))

(defun sf/org-update-agenda-files (&rest _)
  "Set org-agenda-files to active files."
  (setq org-agenda-files (sf/org-active-files)))

(advice-add 'org-agenda :before #'sf/org-update-agenda-files)
(advice-add 'org-todo-list :before #'sf/org-update-agenda-files)
#+end_src

** Agenda Views
Custom agenda with vulpea integration.
#+begin_src emacs-lisp
(setq org-agenda-prefix-format
      '((agenda . " %i %(vulpea-agenda-category 12)%?-12t% s")
        (todo . " %i %(vulpea-agenda-category 12) ")
        (tags . " %i %(vulpea-agenda-category 12) ")
        (search . " %i %(vulpea-agenda-category 12) ")))

(setq org-agenda-custom-commands
   `((" " "Agenda"
      (,vulpea-agenda-cmd-refile
       ,vulpea-agenda-cmd-today
       ,vulpea-agenda-cmd-focus
       ,vulpea-agenda-cmd-waiting)
      ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))))
#+end_src

** Capture Templates
Todo capture with vulpea auto-tagging. Prompts for person/project and files todo in their node.
#+begin_src emacs-lisp
(defun sf/capture-select-person ()
  "Select a person node and return its file path."
  (let ((note (vulpea-select-from "Person"
                :filter-fn (lambda (note)
                             (let ((tags (vulpea-note-tags note)))
                               (seq-find (lambda (tag) (string-prefix-p "@" tag)) tags))))))
    (if note
        (vulpea-note-path note)
      (user-error "No person selected"))))

(defun sf/capture-select-project ()
  "Select a project node and return its file path."
  (let ((note (vulpea-select-from "Project"
                :filter-fn (lambda (note)
                             (member "project" (vulpea-note-tags note))))))
    (if note
        (vulpea-note-path note)
      (user-error "No project selected"))))

(after! org
  (setq org-capture-templates
        '(("t" "Todo (person)" entry
           (file+headline sf/capture-select-person "Tasks")
           "* TODO %?\n%U\n" :prepend t)
          ("T" "Todo (project)" entry
           (file+headline sf/capture-select-project "Tasks")
           "* TODO %?\n%U\n" :prepend t)
          ("n" "Note" entry
           (file+headline "~/org-roam/inbox.org" "Notes")
           "* %?\n%U\n"))))
#+end_src

** Babel
Auto-confirm R code execution (don't prompt every time).
#+begin_src emacs-lisp
(defun my-org-confirm-babel-evaluate (lang body)
  (not (string= lang "R")))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)

(setq org-babel-default-header-args:R '((:session . "*R*") (:exports . "both") (:results . "output")))
#+end_src

* Bibliography
** BibTeX Auto-key Generation
When inserting references, automatically generate citation keys in format: =AuthorYY_FirstThreeWords=
#+begin_src emacs-lisp
(setq biblio-bibtex-use-autokey t
      bibtex-autokey-year-length 2
      bibtex-autokey-year-title-separator "_"
      bibtex-autokey-titlewords 3
      bibtex-autokey-titleword-separator ""
      bibtex-autokey-titleword-length 20)
#+end_src

** Keybindings
| Key       | Action                                |
|-----------+---------------------------------------|
| =SPC B d= | Insert BibTeX from DOI                |
| =SPC B s= | Search papers (all sources)           |
| =SPC B c= | Search CrossRef                       |

In search results buffer:
| Key   | Action              |
|-------+---------------------|
| =i=   | Insert entry        |
| =RET= | Open URL            |
| =c=   | Copy to kill ring   |
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("B" . "bibliography")
       :desc "Insert from DOI" "d" #'biblio-doi-insert-bibtex
       :desc "Search papers" "s" #'biblio-lookup
       :desc "Search CrossRef" "c" #'biblio-crossref-lookup))
#+end_src

* Evil Enhancements
** Embrace
Extends evil-surround with mode-specific surrounds.

In LaTeX/TeX modes:
| Key   | Surround with          |
|-------+------------------------|
| =S c= | =\command{}= (prompts) |
| =S l= | =\begin{env}...\end{env}= |

Standard evil-surround keys still work everywhere (=S (=, =S "=, =S t= for HTML tags, etc.)
#+begin_src emacs-lisp
(use-package! evil-embrace
  :after evil-surround
  :config
  (evil-embrace-enable-evil-surround-integration)
  ;; Enable mode-specific hooks (LaTeX, org, etc.)
  (add-hook 'LaTeX-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'plain-tex-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'tex-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'org-mode-hook #'embrace-org-mode-hook)
  (setq evil-embrace-show-help-p t))
#+end_src

** Snipe
Evil-snipe enhances =f=/=F=/=t=/=T= with 2-character search.
By default it only searches the current line; this extends it to the visible area.

| Key     | Action                          |
|---------+---------------------------------|
| =s xy=  | Jump to next "xy"               |
| =S xy=  | Jump to previous "xy"           |
| =;= / =,= | Repeat forward/backward       |
#+begin_src emacs-lisp
(setq evil-snipe-scope 'visible)
#+end_src

* AI Tools
** Copilot
GitHub Copilot integration. Tab to accept completions.
#+begin_src emacs-lisp
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))
#+end_src

** GPTel
Chat with Claude directly in Emacs.
#+begin_src emacs-lisp
(setq
 gptel-model 'claude-3-5-haiku-20241022
 gptel-backend (gptel-make-anthropic "Claude"
                 :stream t :key gptel-api-key))
#+end_src

** Aider
AI pair programming tool. =SPC c A= opens the transient menu.
#+begin_src emacs-lisp
(use-package! aidermacs
  :custom
  (aidermacs-use-architect-mode t)
  (aidermacs-default-model "sonnet"))

(map! :after aidermacs
      :leader
      :desc "aidermacs"
  "c A" #'aidermacs-transient-menu)
#+end_src

** Claude Code
Two packages for Claude Code integration:
- =claude-code.el= - Terminal interface (=C-c c=)
- =claude-code-ide.el= - IDE integration with MCP tools (=C-c C-'=)

*Tip:* In the Claude Code vterm buffer, use =C-c C-t= to enter copy mode for scrolling,
then =ESC= to enable normal vim motions, =C-c C-t= again to exit.
#+begin_src emacs-lisp
(use-package claude-code
  :vc (:url "https://github.com/stevemolitor/claude-code.el" :rev :newest)
  :config (claude-code-mode)
  :bind-keymap ("C-c c" . claude-code-command-map))

(use-package! claude-code-ide
  :config
  (setq claude-code-ide-focus-on-open nil)
  (claude-code-ide-emacs-tools-setup)

  ;; Scroll claude buffer to end after workspace switch
  (defun sf/claude-scroll-to-end ()
    "Scroll any visible claude buffer to end."
    (dolist (win (window-list))
      (when (string-match-p "\\*claude-code" (buffer-name (window-buffer win)))
        (with-selected-window win
          (goto-char (point-max))
          (recenter -1)))))

  (defun sf/claude-scroll-after-workspace-switch (&rest _)
    "Schedule claude buffer scroll after workspace switch."
    (run-with-idle-timer 0.2 nil #'sf/claude-scroll-to-end))

  (add-hook 'persp-activated-functions #'sf/claude-scroll-after-workspace-switch)
  (add-hook 'window-configuration-change-hook
            (lambda ()
              (when (cl-some (lambda (w)
                              (string-match-p "\\*claude-code" (buffer-name (window-buffer w))))
                            (window-list))
                (run-with-idle-timer 0.1 nil #'sf/claude-scroll-to-end)))))

;; Doom-style keybinding for claude-code-ide
(map! :leader
      "'" #'claude-code-ide-menu)
#+end_src

** Atomic Chrome
Edit browser text areas with Emacs. Install the "Atomic Chrome" browser extension.
#+begin_src emacs-lisp
(use-package! atomic-chrome
  :commands (atomic-chrome-start-server)
  :config
  (setq-default atomic-chrome-extension-type-list '(atomic-chrome))
  (atomic-chrome-start-server))
#+end_src
