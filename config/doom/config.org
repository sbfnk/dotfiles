#+TITLE: Doom Emacs Configuration
#+AUTHOR: Sebastian Funk
#+PROPERTY: header-args:emacs-lisp :tangle yes :results silent

This is my literate Doom Emacs configuration. Each section contains explanations
of what the code does and why certain choices were made.

After editing this file, run =doom sync= to regenerate config.el and packages.el.

* Packages
:PROPERTIES:
:header-args:emacs-lisp: :tangle packages.el
:END:

These package declarations are tangled to =packages.el=. Doom uses these to
install packages from MELPA, ELPA, or directly from git repos.

** ESS Extensions
#+begin_src emacs-lisp
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

(package! ess-smart-equals)        ; context-aware = key in ESS
(package! tree-sitter-ess-r)       ; tree-sitter support for R
#+end_src

** Org Extensions
#+begin_src emacs-lisp
(package! org-ref)                 ; citations and cross-references
(package! vulpea)                  ; org-roam workflow helpers
#+end_src

** Communication
#+begin_src emacs-lisp
(package! telega)                  ; Telegram client
(package! mastodon)                ; Mastodon client
#+end_src

** AI Tools
#+begin_src emacs-lisp
(package! copilot
  :recipe (:host github :repo "zerolfx/copilot.el" :files ("*.el" "dist")))
(package! aidermacs)               ; Aider AI pair programming
(package! claude-code-ide
  :recipe (:host github :repo "manzaltu/claude-code-ide.el"))
#+end_src

** Development
#+begin_src emacs-lisp
(package! quarto-mode)             ; Quarto documents
(package! eglot-jl)                ; Julia LSP via eglot
(package! code-review
  :recipe (:host github :repo "doomelpa/code-review"))
#+end_src

** Editing
#+begin_src emacs-lisp
(package! evil-embrace)            ; mode-specific surrounds
(package! atomic-chrome)           ; edit browser text in Emacs
#+end_src

* Private Configuration
Load private settings (emails, accounts) from a separate file.
This file lives in the private dotfiles repo and is symlinked to =~/.config/doom-private/=.
#+begin_src emacs-lisp
(load! "private.el" "~/.config/doom-private" t)
#+end_src

* Basic Configuration
** Fonts
- =Fira Code= - monospace font with ligatures for code
- =Source Sans 3= - clean sans-serif for prose/variable-pitch

Adjust =:size= if text is too small/large on your display.
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "Fira Code" :size 12 :weight 'semi-light)
      doom-variable-pitch-font (font-spec :family "Source Sans 3" :size 13))
#+end_src

** Theme and UI
#+begin_src emacs-lisp
(setq doom-theme 'doom-one)
(setq display-line-numbers-type t)
#+end_src

** Show Modeline in All Popups
Doom's popup system hides the modeline by default. Always show it so we can
tell which window has focus.
#+begin_src emacs-lisp
(defadvice! +popup-always-show-modeline-a (&rest _)
  "Always show modeline in popups."
  :after #'+popup-set-modeline-on-enable-h
  (setq-local mode-line-format (default-value 'mode-line-format)))
#+end_src

** Highlight Active Modeline
Make the active window's modeline more prominent. Uses the theme's highlight color
so it works across different themes.
#+begin_src emacs-lisp
(custom-set-faces!
  '(mode-line :inherit highlight :box nil)
  '(mode-line-inactive :inherit shadow :box nil))
#+end_src

** macOS Modifier Keys
This makes Emacs feel more natural on macOS:
- *Command* (⌘) → Meta (M-) for Emacs commands
- *Option* (⌥) → Super (s-) available for custom bindings
- *Right Option* → passes through for special characters (umlauts, etc.)
#+begin_src emacs-lisp
(setq mac-option-modifier 'super)
(setq mac-right-option-modifier 'none)
(setq mac-command-modifier 'meta)
#+end_src

** GPG
Allow Emacs to prompt for GPG passphrase in minibuffer.
#+begin_src emacs-lisp
(setf epa-pinentry-mode 'loopback)
#+end_src

* Email (mu4e)
I use mu4e for email with multiple accounts. Account contexts are defined in =private.el=.

** Bookmarks
Quick access to frequently used mail views. Press the shortcut key in mu4e main view.
#+begin_src emacs-lisp
(after! mu4e
  (setq mu4e-bookmarks
        '(("(maildir:/work/inbox OR maildir:/work/\"Sent Items\") (date:today..now OR flag:unread) " "Work email (today)" ?b)
          ("(maildir:/work/inbox OR maildir:/work/\"Sent Items\") " "Work email" ?B)
          ("(maildir:/gmx/INBOX OR maildir:/gmx/Gesendet) (date:today..now OR flag:unread) " "Various email (new)" ?m)
          ("(maildir:/gmx/INBOX OR maildir:/gmx/Gesendet) " "Various email" ?M)
          ("(maildir:/gmail/inbox OR maildir:/gmail/[Gmail]/\".Sent Mail\") (date:today..now OR flag:unread) " "Private email (new)" ?p)
          ("(maildir:/gmail/inbox OR maildir:/gmail/[Gmail]/\".Sent Mail\") " "Private email" ?P)
          ("(maildir:/wedding/inbox OR maildir:/wedding/[Gmail]/\".Sent Mail\") (date:today..now OR flag:unread) " "Joint email (new)" ?w)
          ("(maildir:/wedding/inbox OR maildir:/wedding/[Gmail]/\".Sent Mail\") " "Joint email" ?W)
          ("(maildir:/rph/inbox OR maildir:/rph/[Gmail]/\".Sent Mail\") (date:today..now OR flag:unread) " "RPH email (new)" ?r)
          ("(maildir:/rph/inbox OR maildir:/rph/[Gmail]/\".Sent Mail\") " "RPH email" ?R)
          ("flag:unread" "New email" ?n)))
  (setq mu4e-change-filenames-when-moving t
        mu4e-update-interval 300))
#+end_src

** Update Behavior
By default, =U= in mu4e fetches mail AND re-indexes. Since I run mbsync as a cron
job, I usually just want to re-index. This inverts the prefix behavior:
- =U= → just re-index (fast)
- =C-u U= → fetch mail and re-index
#+begin_src emacs-lisp
(defun sf/mu4e-update-mail-and-index (orig-fun prefix &rest args)
  (interactive "P")
  (if prefix (funcall orig-fun nil) (mu4e-update-index)))

(advice-add 'mu4e-update-mail-and-index
            :around #'sf/mu4e-update-mail-and-index)
#+end_src

** Default Identity
Set default From address (used when composing new mail, not replying).
#+begin_src emacs-lisp
(setq user-full-name "Sebastian Funk"
      user-mail-address "sebastian.funk@work.ac.uk")
#+end_src

** Load Notmuch at Startup
Load notmuch eagerly so all keybindings work immediately.
#+begin_src emacs-lisp
(require 'notmuch)
#+end_src

** Notmuch Saved Searches
Bookmarks for quick access to inboxes and common searches.
#+begin_src emacs-lisp
(after! notmuch
  (setq notmuch-saved-searches
        '((:name "inbox"      :query "tag:inbox"                    :key "i")
          (:name "unread"     :query "tag:unread"                   :key "u")
          (:name "flagged"    :query "tag:flagged"                  :key "f")
          (:name "sent"       :query "tag:sent"                     :key "s")
          (:name "drafts"     :query "tag:draft"                    :key "d")
          (:name "all"        :query "*"                            :key "a")
          ;; Per-account inboxes
          (:name "work"      :query "folder:work/INBOX"           :key "l")
          (:name "private"    :query "folder:private/INBOX"         :key "p")
          (:name "joint"      :query "folder:joint/INBOX"           :key "j")
          (:name "gmx"        :query "folder:gmx/INBOX"             :key "g")
          (:name "sbstnfnk"   :query "folder:sbstnfnk/INBOX"        :key "b")
          (:name "sebfnk"     :query "folder:sebfnk/INBOX"          :key "k"))))
#+end_src

** Notmuch Identities
Auto-select From address based on the message being replied to.
#+begin_src emacs-lisp
(after! notmuch
  ;; All identities
  (setq notmuch-identities
        '("Sebastian Funk <sebastian.funk@work.ac.uk>"
          "Sebastian Funk <funk.seb@gmail.com>"
          "Sebastian Funk <sgwinchh@gmail.com>"
          "Sebastian Funk <sbstnfnk@gmail.com>"
          "Sebastian Funk <sebfnk@gmail.com>"
          "Sebastian Funk <funks@gmx.net>"
          "Sebastian Funk <sebfnk@yahoo.co.uk>"))

  ;; Default identity - use "Sent" not "Sent Items" (space causes issues)
  (setq notmuch-fcc-dirs
        '(("sebastian.funk@work.ac.uk" . "work/Sent")
          ("funk.seb@gmail.com" . "private/[Gmail]/Sent Mail")
          ("sgwinchh@gmail.com" . "joint/[Gmail]/Sent Mail")
          ("funks@gmx.net" . "gmx/Gesendet")
          (".*" . "work/Sent")))

  ;; Auto-detect identity from To/Cc when replying
  (setq notmuch-always-prompt-for-sender nil)

  ;; Function to detect identity from original message
  (defun sf/notmuch-guess-identity ()
    "Guess identity based on To/Cc of message being replied to."
    (when-let* ((original-to (notmuch-show-get-to))
                (original-cc (notmuch-show-get-cc))
                (all-recipients (concat original-to " " original-cc)))
      (seq-find (lambda (identity)
                  (let ((addr (cadr (mail-extract-address-components identity))))
                    (string-match-p (regexp-quote addr) all-recipients)))
                notmuch-identities)))

  ;; Set From when composing reply
  (defun sf/notmuch-set-from-for-reply ()
    "Set From header based on detected identity."
    (when-let ((identity (sf/notmuch-guess-identity)))
      (message-replace-header "From" identity)))

  (add-hook 'notmuch-mua-reply-hook #'sf/notmuch-set-from-for-reply)

  ;; Easy From switching: C-c C-f f cycles identities
  (defun sf/notmuch-cycle-identity ()
    "Cycle through notmuch identities for From header."
    (interactive)
    (let* ((current-from (message-fetch-field "from"))
           (current-addr (and current-from
                              (cadr (mail-extract-address-components current-from))))
           (current-idx (or (seq-position notmuch-identities current-from #'string=)
                            (seq-position notmuch-identities
                                          current-addr
                                          (lambda (id addr)
                                            (string-match-p (regexp-quote addr) id)))
                            -1))
           (next-idx (mod (1+ current-idx) (length notmuch-identities)))
           (next-identity (nth next-idx notmuch-identities)))
      (message-replace-header "From" next-identity)
      (message "From: %s" next-identity)))

  (map! :map notmuch-message-mode-map
        "C-c C-f f" #'sf/notmuch-cycle-identity)

  ;; Address completion from notmuch database
  (setq notmuch-address-command 'internal  ; use built-in completion
        notmuch-address-use-company t)     ; integrate with company-mode

  ;; Also complete in Cc/Bcc fields
  (setq notmuch-address-selection-function
        (lambda (prompt collection initial-input)
          (completing-read prompt collection nil nil initial-input)))

  ;; Open HTML email in browser for complex formatting
  (defun sf/notmuch-view-in-browser ()
    "Open the current email in the system browser."
    (interactive)
    (let* ((msg-id (notmuch-show-get-message-id))
           (html-file (make-temp-file "notmuch-email-" nil ".html")))
      (with-temp-file html-file
        (call-process "notmuch" nil t nil "show" "--format=raw" msg-id)
        (goto-char (point-min))
        ;; Try to extract HTML part, fallback to raw
        (if (re-search-forward "Content-Type: text/html" nil t)
            (progn
              (re-search-forward "^$")
              (delete-region (point-min) (point))
              ;; Remove MIME boundary at end if present
              (goto-char (point-max))
              (when (re-search-backward "^--" nil t)
                (delete-region (point) (point-max))))
          ;; No HTML, wrap plain text
          (goto-char (point-min))
          (insert "<html><body><pre>")
          (goto-char (point-max))
          (insert "</pre></body></html>")))
      (browse-url (concat "file://" html-file))))

  ;; Fix evil-mode overriding notmuch navigation keys
  (add-hook! 'notmuch-show-mode-hook
    (defun sf/notmuch-show-evil-bindings ()
      (evil-local-set-key 'normal "n" #'notmuch-show-next-open-message)
      (evil-local-set-key 'normal "p" #'notmuch-show-previous-open-message)
      (evil-local-set-key 'normal "N" #'notmuch-show-next-thread-show)
      (evil-local-set-key 'normal "P" #'notmuch-show-previous-thread-show)
      (evil-local-set-key 'normal "J" #'notmuch-jump-search)
      (evil-local-set-key 'normal "V" #'sf/notmuch-view-in-browser)
      (evil-local-set-key 'normal "q" #'notmuch-bury-or-kill-this-buffer)))

  ;; Global keybinding for composing new email
  (map! :leader
        :desc "Compose email" "m" #'notmuch-mua-new-mail))
#+end_src

** HTML Email Composition with org-msg
Compose emails in org-mode, send as HTML+text multipart.
#+begin_src emacs-lisp
(after! notmuch
  (setq mail-user-agent 'notmuch-user-agent)
  (require 'org-msg)
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
        org-msg-startup "hidestars indent inlineimages"
        org-msg-greeting-fmt "\nHi%s,\n\n"
        org-msg-greeting-name-limit 3
        org-msg-default-alternatives '((new . (text html))
                                       (reply-to-html . (text html))
                                       (reply-to-text . (text)))
        org-msg-convert-citation t
        org-msg-signature "

Best,
Sebastian")
  (org-msg-mode 1)
  (map! :map org-msg-edit-mode-map
        "C-c C-a" #'org-msg-attach)
  (setq message-hidden-headers '("Fcc")))
#+end_src

** Sending Mail
Use msmtpq for queue-based sending. Emails queue locally and send when connection is available.
Handles flaky connections gracefully - never loses mail. Queue flushed periodically via launchd.
Config in =~/.msmtprc=, queue in =~/.msmtpq/=, logs to =~/.log/msmtp.log=.

*** Core Setup
#+begin_src emacs-lisp
(after! message
  ;; Use msmtpq for queue-based sending
  (setq sendmail-program "msmtpq"
        message-send-mail-function #'message-send-mail-with-sendmail
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from")))
#+end_src

*** Queue Management
#+begin_src emacs-lisp
(defun sf/mail-queue-count ()
  "Return number of messages in msmtpq queue."
  (let ((queue-dir (expand-file-name "~/.msmtpq")))
    (if (file-directory-p queue-dir)
        (length (directory-files queue-dir nil "\\.mail$"))
      0)))

(defun sf/mail-queue-flush ()
  "Flush the msmtpq queue."
  (interactive)
  (let ((count (sf/mail-queue-count)))
    (if (zerop count)
        (message "Mail queue empty")
      (message "Flushing %d queued message(s)..." count)
      (async-shell-command "msmtp-queue -r" "*msmtp-queue*"))))

(defun sf/mail-queue-list ()
  "Show queued messages."
  (interactive)
  (async-shell-command "msmtp-queue -d" "*msmtp-queue*"))
#+end_src

*** Logging
Log sent messages from Emacs side (msmtp also logs to ~/.log/msmtp.log).
#+begin_src emacs-lisp
(defvar sf/mail-log-file "~/.log/emacs-mail.log"
  "Log file for mail operations.")

(defun sf/mail-log (format-string &rest args)
  "Log a message to the mail log file."
  (let ((msg (format "[%s] %s\n"
                     (format-time-string "%Y-%m-%d %H:%M:%S")
                     (apply #'format format-string args))))
    (append-to-file msg nil sf/mail-log-file)
    (message "Mail: %s" (string-trim msg))))

(defun sf/mail-log-sent ()
  "Log when a message is sent."
  (sf/mail-log "SENT: To=%s Subject=%s"
               (message-fetch-field "to")
               (message-fetch-field "subject")))

(add-hook 'message-sent-hook #'sf/mail-log-sent)

;; Keybinding to view log
(map! :leader
      (:prefix ("o n" . "notmuch/mail")
       :desc "Flush queue" "f" #'sf/mail-queue-flush
       :desc "List queue" "q" #'sf/mail-queue-list
       :desc "Queue count" "c" (cmd! (message "Mail queue: %d" (sf/mail-queue-count)))
       :desc "View Emacs log" "l" (cmd! (find-file sf/mail-log-file))
       :desc "View msmtp log" "L" (cmd! (find-file "~/.log/msmtp.log"))))
#+end_src

*** Credentials
Use macOS Keychain for non-OAuth accounts (Gmail, etc).
#+begin_src emacs-lisp
;; Use macOS Keychain as primary auth source (same passwords as mbsync)
(setq auth-sources '(macos-keychain-internet macos-keychain-generic "~/.authinfo.gpg"))
#+end_src

* ESS (Emacs Speaks Statistics)
ESS provides IDE-like features for R, Julia, and other statistical languages.

** Smart Equals and Basic Settings
=ess-smart-equals= makes === context-aware - it inserts =<-= in the right places.
#+begin_src emacs-lisp
(after! ess
  (use-package ess-smart-equals
    :init   (setq ess-smart-equals-extra-ops '(brace paren percent))
    :after  (:any ess-r-mode inferior-ess-r-mode ess-r-transcript-mode)
    :config (ess-smart-equals-activate))
  (setq comint-scroll-to-bottom-on-output 'others)
  (setq comint-scroll-show-maximum-output t)
  (setq ess-nuke-trailing-whitespace-p t)
  (setq ess-r-smart-operators t)
  (setq comint-scroll-to-bottom-on-input 'this)
#+end_src

** Pipe Operators
Custom functions for inserting the native R pipe operator =|>=.

| Key   | Action                    |
|-------+---------------------------|
| =C-`= | Insert pipe with newline  |
| =C-~= | Insert pipe without newline |
#+begin_src emacs-lisp
  (defun then_newline_R_operator ()
    "|> operator or 'then' pipe operator"
    (interactive)
    (just-one-space 1)
    (insert "|> ")
    (ess-roxy-newline-and-indent))
  (defun then_R_operator ()
    "|> operator or 'then' pipe operator"
    (interactive)
    (just-one-space 1)
    (insert "|> "))
  (setq tab-always-indent 'complete)
#+end_src

** Roxygen Templates
Default template for R documentation comments.
#+begin_src emacs-lisp
  (setq ess-roxy-template-alist
    (list (cons "description"  ".. content for \\description{} (no empty lines) ..")
          (cons "param"  "")
          (cons "return" "")
          (cons "examples" ""))))
#+end_src

** Keybindings
#+begin_src emacs-lisp
(map! :after ess
 (:map inferior-ess-r-mode-map
  :n "0" #'comint-bol
  :i "C-`" #'then_newline_R_operator
  :i "C-~" #'then_R_operator)
 (:map ess-mode-map
  :i "C-`" #'then_newline_R_operator
  :i "C-~" #'then_R_operator)
 (:map comint-mode-map
  :i "M-k" #'comint-previous-matching-input-from-input
  :i "M-j" #'comint-next-matching-input-from-input))
#+end_src

** Inferior ESS Hook
#+begin_src emacs-lisp
(defun my-inferior-ess-init ()
  (setq-local ansi-color-for-comint-mode 'filter)
  (smartparens-mode 1))
(add-hook 'inferior-ess-mode-hook 'my-inferior-ess-init)
#+end_src

* Julia
** Why ESS-Julia instead of julia-repl?
Doom's default Julia setup uses =julia-repl=, but it has limitations:
- Each buffer gets its own REPL (annoying in Quarto with multiple code blocks)
- No easy way to switch between multiple Julia sessions

ESS-Julia gives us the same workflow as R:
- =C-c C-s= to switch between Julia sessions
- =C-u M-x julia= to start a named session
- All buffers share the same REPL by default

** ESS-Julia Mode
#+begin_src emacs-lisp
(after! julia-mode
  ;; Disable julia-repl-mode which Doom enables by default
  (remove-hook 'julia-mode-hook #'julia-repl-mode)
  ;; Use ess-julia-mode for .jl files
  (add-to-list 'auto-mode-alist '("\\.jl\\'" . ess-julia-mode)))

(after! ess
  ;; Julia executable (adjust path if needed)
  (setq inferior-julia-program "julia")

  ;; Window placement for Julia REPL - right side, 45% width
  (set-popup-rule! "^\\*julia.*\\*$"
    :side 'right :size 0.45 :select nil :quit nil :ttl nil))
#+end_src

** Quarto/Polymode Integration
This makes =M-n v v= (eval chunk) work in Julia code blocks within Quarto files,
just like it does for R. Without this, each code block would try to start a new REPL.

| Key       | Action                    |
|-----------+---------------------------|
| =M-n v v= | Eval current chunk        |
| =M-n v b= | Eval whole buffer         |
| =C-c C-c= | Eval region/paragraph     |
| =C-c C-s= | Switch Julia session      |
#+begin_src emacs-lisp
(after! polymode
  ;; Tell polymode to use ess-julia-mode for julia code blocks
  (add-to-list 'polymode-mode-name-override-alist '(julia . ess-julia-mode))

  ;; Define the eval function for Julia (like poly-R does for R)
  (defun poly-julia-eval-region (beg end msg)
    "Eval region in Julia using ESS."
    (ess-eval-region beg end nil msg))

  ;; Set up polymode eval for ess-julia-mode in polymode buffers
  (add-hook 'polymode-init-inner-hook
            (lambda ()
              (when (eq major-mode 'ess-julia-mode)
                (setq-local polymode-eval-region-function #'poly-julia-eval-region)))))
#+end_src

** REPL Display
Ensure Julia REPL window is displayed when evaluating code (it was staying hidden).
#+begin_src emacs-lisp
(after! ess
  (defun my/display-julia-repl (&rest _)
    "Display Julia REPL buffer if it exists."
    (when-let ((buf (seq-find (lambda (b)
                                (string-match-p "^\\*julia:" (buffer-name b)))
                              (buffer-list))))
      (unless (get-buffer-window buf)
        (display-buffer buf '((display-buffer-reuse-window
                               display-buffer-pop-up-window)
                              (reusable-frames . nil))))))
  ;; Show buffer after eval commands
  (advice-add 'ess-eval-region :after #'my/display-julia-repl)
  (advice-add 'ess-eval-region-or-function-or-paragraph :after #'my/display-julia-repl))

(setq lsp-julia-package-dir nil)
(setq lsp-julia-default-environment "~/.julia/environments/v1.11")
#+end_src

* Python
#+begin_src emacs-lisp
(setq python-interpreter "~/.venv/bin/python")
(setq python-shell-interpreter "~/.venv/bin/python")
#+end_src

* Polymode
Disable LSP integration with polymode to avoid issues with multi-mode buffers.
See https://github.com/polymode/poly-R/issues/34
#+begin_src emacs-lisp
(setq polymode-lsp-integration nil)
#+end_src

* Magit
** Default Clone Directory
#+begin_src emacs-lisp
(after! magit
  (setq magit-clone-default-directory "~/code/"))
#+end_src

** Automatic Workspace Creation
This is a custom workflow enhancement. When you run =magit-status= or =magit-clone=
on a repository:

1. The repo is added to projectile's known projects (so =SPC p p= finds it)
2. A workspace is created/switched to, named after the repo
3. Magit opens fullframe in that workspace

This means =SPC g g ~/code/new-project= instantly sets up a complete workspace.
#+begin_src emacs-lisp
(after! magit
  (defun my/magit-setup-workspace ()
    "Ensure project is registered with projectile and has a workspace."
    (when-let* ((root (or (magit-toplevel) default-directory))
                (name (file-name-nondirectory (directory-file-name root))))
      ;; Add to projectile's known projects
      (projectile-add-known-project root)
      ;; Create or switch to workspace (only if not already there)
      (unless (string= (+workspace-current-name) name)
        (if (member name (+workspace-list-names))
            (+workspace-switch name)
          ;; New workspace
          (+workspace-switch name t)
          ;; Clean up after everything settles
          (run-at-time 0.1 nil #'delete-other-windows)))))

  ;; Run when opening magit-status
  (add-hook 'magit-status-mode-hook #'my/magit-setup-workspace)
  ;; Run after cloning a repo
  (add-hook 'magit-post-clone-hook #'my/magit-setup-workspace))
#+end_src

* Workspaces and Projectile
Doom's workspaces (built on =persp-mode=) provide buffer isolation per project.
This is essential for keeping different projects separate.

** Key Bindings Reference
| Key           | Action                              |
|---------------+-------------------------------------|
| =SPC TAB TAB= | Switch workspace                    |
| =SPC TAB n=   | New workspace                       |
| =SPC TAB d=   | Delete workspace                    |
| =SPC TAB r=   | Rename workspace                    |
| =SPC b b=     | Switch buffer (workspace only)      |
| =SPC b B=     | Switch buffer (all buffers)         |
| =SPC b r=     | Remove buffer from workspace        |
| =SPC p p=     | Switch project (creates workspace)  |

** Basic Setup
#+begin_src emacs-lisp
(setq +workspaces-on-switch-project-behavior t)  ; auto-create workspace per project
(setq persp-auto-save-opt 1)                      ; save workspaces on exit
(setq projectile-project-search-path '("~/code/")) ; where to find projects
#+end_src

** Auto-rename Workspaces
By default, workspaces get names like "code/EpiNow2". This strips the path prefix
so they're just "EpiNow2". If a workspace with that name already exists, switch to it
instead of creating a duplicate.
#+begin_src emacs-lisp
(after! persp-mode
  (add-hook 'projectile-after-switch-project-hook
            (lambda ()
              (let* ((current (+workspace-current-name))
                     (basename (file-name-nondirectory (directory-file-name current))))
                (unless (string= current basename)
                  (if (member basename (+workspace-list-names))
                      ;; Workspace with basename exists - switch to it and delete the new one
                      (let ((new-ws current))
                        (+workspace-switch basename)
                        (+workspace-delete new-ws))
                    ;; No conflict - just rename
                    (+workspace/rename basename)))))))
#+end_src

** Buffer Management
Remove a buffer from the current workspace without killing it.
The buffer is still accessible via =SPC b B= (global buffer list).
#+begin_src emacs-lisp
(map! :leader
      :desc "Remove buffer from workspace" "b W" #'persp-remove-buffer)
#+end_src

* Org Mode
** Directories
#+begin_src emacs-lisp
(setq org-directory "~/org")
;; org-agenda-files is dynamically updated by vulpea-agenda-files-update
;; which includes all files with 'project' tag
#+end_src

** Agenda Views
Custom agenda with vulpea integration.
#+begin_src emacs-lisp
(setq org-agenda-prefix-format
      '((agenda . " %i %(vulpea-agenda-category 12)%?-12t% s")
        (todo . " %i %(vulpea-agenda-category 12) ")
        (tags . " %i %(vulpea-agenda-category 12) ")
        (search . " %i %(vulpea-agenda-category 12) ")))

(setq org-agenda-custom-commands
   `((" " "Agenda"
      (,vulpea-agenda-cmd-refile
       ,vulpea-agenda-cmd-today
       ,vulpea-agenda-cmd-focus
       ,vulpea-agenda-cmd-waiting)
      ((org-agenda-buffer-name vulpea-agenda-main-buffer-name)))))
#+end_src

** Babel
Auto-confirm R code execution (don't prompt every time).
#+begin_src emacs-lisp
(defun my-org-confirm-babel-evaluate (lang body)
  (not (string= lang "R")))
(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)

(setq org-babel-default-header-args:R '((:session . "*R*") (:exports . "both") (:results . "output")))
#+end_src

* Bibliography
** BibTeX Auto-key Generation
When inserting references, automatically generate citation keys in format: =AuthorYY_FirstThreeWords=
#+begin_src emacs-lisp
(setq biblio-bibtex-use-autokey t
      bibtex-autokey-year-length 2
      bibtex-autokey-year-title-separator "_"
      bibtex-autokey-titlewords 3
      bibtex-autokey-titleword-separator ""
      bibtex-autokey-titleword-length 20)
#+end_src

** Keybindings
| Key       | Action                                |
|-----------+---------------------------------------|
| =SPC B d= | Insert BibTeX from DOI                |
| =SPC B s= | Search papers (all sources)           |
| =SPC B c= | Search CrossRef                       |

In search results buffer:
| Key   | Action              |
|-------+---------------------|
| =i=   | Insert entry        |
| =RET= | Open URL            |
| =c=   | Copy to kill ring   |
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("B" . "bibliography")
       :desc "Insert from DOI" "d" #'biblio-doi-insert-bibtex
       :desc "Search papers" "s" #'biblio-lookup
       :desc "Search CrossRef" "c" #'biblio-crossref-lookup))
#+end_src

* Evil Enhancements
** Embrace
Extends evil-surround with mode-specific surrounds.

In LaTeX/TeX modes:
| Key   | Surround with          |
|-------+------------------------|
| =S c= | =\command{}= (prompts) |
| =S l= | =\begin{env}...\end{env}= |

Standard evil-surround keys still work everywhere (=S (=, =S "=, =S t= for HTML tags, etc.)
#+begin_src emacs-lisp
(use-package! evil-embrace
  :after evil-surround
  :config
  (evil-embrace-enable-evil-surround-integration)
  ;; Enable mode-specific hooks (LaTeX, org, etc.)
  (add-hook 'LaTeX-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'plain-tex-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'tex-mode-hook #'embrace-LaTeX-mode-hook)
  (add-hook 'org-mode-hook #'embrace-org-mode-hook)
  (setq evil-embrace-show-help-p t))
#+end_src

** Snipe
Evil-snipe enhances =f=/=F=/=t=/=T= with 2-character search.
By default it only searches the current line; this extends it to the visible area.

| Key     | Action                          |
|---------+---------------------------------|
| =s xy=  | Jump to next "xy"               |
| =S xy=  | Jump to previous "xy"           |
| =;= / =,= | Repeat forward/backward       |
#+begin_src emacs-lisp
(setq evil-snipe-scope 'visible)
#+end_src

* AI Tools
** Copilot
GitHub Copilot integration. Tab to accept completions.
#+begin_src emacs-lisp
(use-package! copilot
  :hook (prog-mode . copilot-mode)
  :bind (:map copilot-completion-map
              ("<tab>" . 'copilot-accept-completion)
              ("TAB" . 'copilot-accept-completion)
              ("C-TAB" . 'copilot-accept-completion-by-word)
              ("C-<tab>" . 'copilot-accept-completion-by-word)))
#+end_src

** GPTel
Chat with Claude directly in Emacs.
#+begin_src emacs-lisp
(setq
 gptel-model 'claude-3-5-haiku-20241022
 gptel-backend (gptel-make-anthropic "Claude"
                 :stream t :key gptel-api-key))
#+end_src

** Aider
AI pair programming tool. =SPC c A= opens the transient menu.
#+begin_src emacs-lisp
(use-package! aidermacs
  :custom
  (aidermacs-use-architect-mode t)
  (aidermacs-default-model "sonnet"))

(map! :after aidermacs
      :leader
      :desc "aidermacs"
  "c A" #'aidermacs-transient-menu)
#+end_src

** Claude Code
Two packages for Claude Code integration:
- =claude-code.el= - Terminal interface (=C-c c=)
- =claude-code-ide.el= - IDE integration with MCP tools (=C-c C-'=)

*Tip:* In the Claude Code vterm buffer, use =C-c C-t= to enter copy mode for scrolling,
then =ESC= to enable normal vim motions, =C-c C-t= again to exit.
#+begin_src emacs-lisp
(use-package claude-code
  :vc (:url "https://github.com/stevemolitor/claude-code.el" :rev :newest)
  :config (claude-code-mode)
  :bind-keymap ("C-c c" . claude-code-command-map))

(use-package! claude-code-ide
  :config
  (setq claude-code-ide-focus-on-open nil)
  (claude-code-ide-emacs-tools-setup)

  ;; Scroll claude buffer to end after workspace switch
  (defun sf/claude-scroll-after-workspace-switch (&rest _)
    "Scroll any visible claude buffer to end after workspace switch."
    (run-with-timer 0.1 nil
      (lambda ()
        (dolist (win (window-list))
          (when (string-match-p "\\*claude-code" (buffer-name (window-buffer win)))
            (with-selected-window win
              (goto-char (point-max))))))))
  (add-hook 'persp-activated-functions #'sf/claude-scroll-after-workspace-switch))

;; Doom-style keybinding for claude-code-ide
(map! :leader
      "'" #'claude-code-ide-menu)
#+end_src

** Atomic Chrome
Edit browser text areas with Emacs. Install the "Atomic Chrome" browser extension.
#+begin_src emacs-lisp
(use-package! atomic-chrome
  :commands (atomic-chrome-start-server)
  :config
  (setq-default atomic-chrome-extension-type-list '(atomic-chrome))
  (atomic-chrome-start-server))
#+end_src
